use serde_yaml::Value;
use std::collections::HashMap;
use once_cell::sync::Lazy;

/// Builder entry for the node registry
pub struct Builder {
    pub tag: &'static str,
    pub build: fn(&Value) -> Result<Box<dyn Node + Send + Sync>, String>,
}

inventory::collect!(Builder);

/// Global registry of node builders
static NODE_BUILDERS: Lazy<HashMap<&'static str, &'static Builder>> = Lazy::new(|| {
    let mut map = HashMap::new();
    for builder in inventory::iter::<Builder> {
        map.insert(builder.tag, builder);
    }
    map
});

/// Build a node from YAML by looking up its type in the registry
pub fn build_node(v: &Value) -> Result<Box<dyn Node + Send + Sync>, String> {
    // If v is just a string ID, we need the full spec
    if let Some(id) = v.as_str() {
        return Err(format!("Cannot build node from ID '{}' - need full spec", id));
    }
    
    let map = v.as_mapping()
        .ok_or_else(|| "Node spec must be a mapping".to_string())?;
    
    let tag = map.get(&Value::String("type".into()))
        .and_then(Value::as_str)
        .ok_or_else(|| "Missing 'type' field in node spec".to_string())?;
    
    NODE_BUILDERS.get(tag)
        .ok_or_else(|| format!("Unknown node type: {}", tag))
        .and_then(|builder| (builder.build)(v))
}

/// Core evaluation trait: compute an f64 from one row of inputs.
pub trait Node {
    fn eval(&self, row: &HashMap<String, f64>) -> f64;
}

/// Arena-based evaluation trait for nodes
pub trait ArenaEvalNode {
    fn eval(&self, values: &[f64]) -> f64;
}

/// Builder entry for node registry
pub struct NodeBuilder {
    pub tag: &'static str,
    pub build: fn(&Value) -> Result<Box<dyn Node + Send + Sync>, String>,
    pub build_arena: fn(&ArenaNode) -> Result<Box<dyn ArenaEvalNode>, String>,
}

inventory::collect!(NodeBuilder);


/// Extract a single-node spec (mapping with 'type') or unpack a full-graph spec by root
pub(crate) fn extract_node_spec(val: &Value) -> Result<Value, String> {
    let map = val.as_mapping().ok_or_else(|| "Spec must be a mapping".to_string())?;
    // single-node spec
    if map.contains_key(&Value::String("type".into())) {
        return Ok(val.clone());
    }
    // graph spec
    let root = map
        .get(&Value::String("root".into()))
        .and_then(Value::as_str)
        .ok_or_else(|| "Missing 'root' in graph spec".to_string())?;
    // graph spec: nodes as mapping or sequence
    if let Some(nmap) = map.get(&Value::String("nodes".into())).and_then(Value::as_mapping) {
        return nmap
            .get(&Value::String(root.into()))
            .cloned()
            .ok_or_else(|| format!("Graph spec: root '{}' not found", root));
    }
    if let Some(nseq) = map.get(&Value::String("nodes".into())).and_then(Value::as_sequence) {
        for node in nseq {
            if let Some(m) = node.as_mapping() {
                if let Some(idv) = m.get(&Value::String("id".into())).and_then(Value::as_i64) {
                    if idv.to_string() == root {
                        return Ok(Value::Mapping(m.clone()));
                    }
                }
            }
        }
        return Err(format!("Graph spec: root '{}' not found in nodes list", root));
    }
    Err("Missing 'nodes' in graph spec".to_string())
}

/// Extension trait tying a YAML `type` tag to its builder.
/// Trait for spec types generated by `#[py_node]` to build engine nodes from YAML.
pub trait NodeDef: Sized {
    /// The `type` tag used in YAML to identify this node.
    const TYPE: &'static str;
    /// Build the concrete engine node from its YAML mapping.
    fn from_yaml(v: &Value) -> Result<Box<dyn Node + Send + Sync>, String>;
    /// Build arena node from spec
    fn from_arena_spec(spec: &ArenaNode) -> Result<Box<dyn ArenaEvalNode>, String> {
        // Default implementation returns error
        Err("Arena spec not implemented for this node type".to_string())
    }
}

/// ------------------------------------------------------------------
/// PhaseÂ 3: Arena-based graph and engine
/// ------------------------------------------------------------------
/// Numeric index for nodes in the arena
pub type NodeId = usize;

/// A flat arena of nodes parsed from YAML.
#[derive(serde::Deserialize)]
pub struct ArenaNode {
    pub id: NodeId,
    #[serde(rename="type")]
    pub tag: String,
    #[serde(flatten)]
    pub fields: HashMap<String, FieldValue>,
}

/// A complete arena graph (list of nodes + root index).
#[derive(serde::Deserialize)]
pub struct ArenaGraph {
    pub nodes: Vec<ArenaNode>,
    pub root: NodeId,
}

/// Possible field values in the arena spec.
#[derive(serde::Deserialize)]
#[serde(untagged)]
pub enum FieldValue {
    One(NodeId),
    Many(Vec<NodeId>),
    Str(String),
    Float(f64),
}

impl ArenaGraph {
    /// Parse an arena graph from its YAML text.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }
}

/// Trait for engines that run an arena graph over input rows.
pub trait Engine {
    /// Engine name
    fn name(&self) -> &str;
    
    /// Given the arena and input rows, produce output rows.
    fn run(&self, graph: &ArenaGraph, rows: Vec<HashMap<String, f64>>)
        -> Vec<HashMap<String, f64>>;
}

/// Simple engine: trigger=graph.root, outputs are given indices.
pub struct ArenaEngine {
    pub outputs: Vec<NodeId>,
}
impl ArenaEngine {
    /// Create with the list of output node IDs to report.
    pub fn new(outputs: Vec<NodeId>) -> Self {
        Self { outputs }
    }
}
impl Engine for ArenaEngine {
    fn name(&self) -> &str {
        "topological"
    }
    
    fn run(&self, graph: &ArenaGraph, rows: Vec<HashMap<String, f64>>)
        -> Vec<HashMap<String, f64>>
    {
        let mut results = Vec::new();
        for row in rows {
            // Topologically evaluate by arena order
            let mut vals = vec![0.0; graph.nodes.len()];
            for node in &graph.nodes {
                let v = match node.tag.as_str() {
                    "input" => {
                        if let FieldValue::Str(col) = &node.fields["name"] {
                            *row.get(col).unwrap_or(&0.0)
                        } else { 0.0 }
                    }
                    "const" => {
                        if let FieldValue::Float(f) = node.fields["value"] {
                            f
                        } else { 0.0 }
                    }
                    "add" => {
                        if let FieldValue::Many(ref children) = node.fields["children"] {
                            children.iter().map(|&i| vals[i]).sum()
                        } else { 0.0 }
                    }
                    "mul" => {
                        if let FieldValue::Many(ref children) = node.fields["children"] {
                            children.iter().map(|&i| vals[i]).product()
                        } else { 0.0 }
                    }
                    "div" => {
                        let l = if let FieldValue::One(i) = node.fields["left"] { vals[i] } else { 0.0 };
                        let r = if let FieldValue::One(i) = node.fields["right"] { vals[i] } else { 1.0 };
                        l / r
                    }
                    other => panic!("Unknown node tag {}", other),
                };
                vals[node.id] = v;
            }
            // Build output record: include trigger and outputs
            let mut rec = HashMap::new();
            rec.insert("trigger".to_string(), vals[graph.root]);
            for &out in &self.outputs {
                rec.insert(format!("output{}", out), vals[out]);
            }
            results.push(rec);
        }
        results
    }
}

/// Input node: reads a column by name.
pub struct InputNodeImpl {
    pub name: String,
}
impl InputNodeImpl {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "input";
}
impl Node for InputNodeImpl {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        *row.get(&self.name).unwrap_or(&0.0)
    }
}

/// Const node: always returns a constant.
pub struct ConstNode {
    pub value: f64,
}
impl ConstNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "const";
}
impl Node for ConstNode {
    fn eval(&self, _: &HashMap<String, f64>) -> f64 {
        self.value
    }
}

/// Add node: sums children.
pub struct AddNode {
    pub children: Vec<Box<dyn Node + Send + Sync>>,
}
impl AddNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "add";
}
impl Node for AddNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|c| c.eval(row)).sum()
    }
}

/// Mul node: multiplies children.
pub struct MulNode {
    pub children: Vec<Box<dyn Node + Send + Sync>>,
}
impl MulNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "mul";
}
impl Node for MulNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|c| c.eval(row)).product()
    }
}

/// Div node: left / right.
pub struct DivNode {
    pub left: Box<dyn Node + Send + Sync>,
    pub right: Box<dyn Node + Send + Sync>,
}
impl DivNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "div";
}
impl Node for DivNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        let l = self.left.eval(row);
        let r = self.right.eval(row);
        l / r
    }
}
/// Lazy evaluation engine - only evaluates needed nodes
pub struct LazyArenaEngine {
    pub outputs: Vec<NodeId>,
}

impl LazyArenaEngine {
    pub fn new(outputs: Vec<NodeId>) -> Self {
        Self { outputs }
    }
    
    fn eval_node(&self, graph: &ArenaGraph, node_id: NodeId, values: &mut Vec<Option<f64>>, row: &HashMap<String, f64>) -> f64 {
        if let Some(val) = values[node_id] {
            return val;
        }
        
        let node = &graph.nodes[node_id];
        let result = match node.tag.as_str() {
            "input" => {
                if let FieldValue::Str(col) = &node.fields["name"] {
                    *row.get(col).unwrap_or(&0.0)
                } else { 0.0 }
            }
            "const" => {
                if let FieldValue::Float(f) = node.fields["value"] {
                    f
                } else { 0.0 }
            }
            "add" => {
                if let FieldValue::Many(ref children) = node.fields["children"] {
                    children.iter().map(|&i| self.eval_node(graph, i, values, row)).sum()
                } else { 0.0 }
            }
            "mul" => {
                if let FieldValue::Many(ref children) = node.fields["children"] {
                    children.iter().map(|&i| self.eval_node(graph, i, values, row)).product()
                } else { 0.0 }
            }
            "div" => {
                let l = if let FieldValue::One(i) = node.fields["left"] { 
                    self.eval_node(graph, i, values, row)
                } else { 0.0 };
                let r = if let FieldValue::One(i) = node.fields["right"] { 
                    self.eval_node(graph, i, values, row) 
                } else { 1.0 };
                l / r
            }
            other => panic!("Unknown node tag {}", other),
        };
        
        values[node_id] = Some(result);
        result
    }
}

impl Engine for LazyArenaEngine {
    fn name(&self) -> &str {
        "lazy"
    }
    
    fn run(&self, graph: &ArenaGraph, rows: Vec<HashMap<String, f64>>) -> Vec<HashMap<String, f64>> {
        let mut results = Vec::new();
        
        for row in rows {
            let mut values = vec![None; graph.nodes.len()];
            
            // Evaluate root
            let root_val = self.eval_node(graph, graph.root, &mut values, &row);
            
            // Evaluate outputs
            let mut rec = HashMap::new();
            rec.insert("trigger".to_string(), root_val);
            
            for &out in &self.outputs {
                let val = self.eval_node(graph, out, &mut values, &row);
                rec.insert(format!("output{}", out), val);
            }
            
            results.push(rec);
        }
        
        results
    }
}

pub struct SamplerCore {
    trigger: Box<dyn Node + Send + Sync>,
    outputs: Vec<Box<dyn Node + Send + Sync>>,
}

impl SamplerCore {
    pub fn new(trigger_yaml: &str, output_yamls: &[&str]) -> Result<Self, String> {
        // unwrap either a single-node or full graph spec for trigger
        let tval: Value = serde_yaml::from_str(trigger_yaml).map_err(|e| e.to_string())?;
        let trigger_spec = extract_node_spec(&tval)
            .map_err(|e| format!("Invalid trigger spec: {}", e))?;
        let trigger = build_node(&trigger_spec)?;

        // unwrap each output spec similarly
        let mut outputs = Vec::with_capacity(output_yamls.len());
        for &yml in output_yamls {
            let oval: Value = serde_yaml::from_str(yml).map_err(|e| e.to_string())?;
            let spec = extract_node_spec(&oval)
                .map_err(|e| format!("Invalid output spec: {}", e))?;
            outputs.push(build_node(&spec)?);
        }
        Ok(SamplerCore { trigger, outputs })
    }

    pub fn run(&self, rows: Vec<HashMap<String, f64>>) -> Vec<HashMap<String, f64>> {
        let mut results = Vec::new();
        let mut prev: Option<f64> = None;
        for row in rows {
            let tval = self.trigger.eval(&row);
            if prev.map_or(true, |p| p != tval) {
                let mut rec = HashMap::new();
                rec.insert("trigger".to_string(), tval);
                for (i, node) in self.outputs.iter().enumerate() {
                    rec.insert(format!("output{}", i), node.eval(&row));
                }
                results.push(rec);
                prev = Some(tval);
            }
        }
        results
    }
}
