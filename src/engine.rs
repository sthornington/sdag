use serde_yaml::Value;
use std::collections::HashMap;

/// Core evaluation trait: compute an f64 from one row of inputs.
pub trait Node {
    fn eval(&self, row: &HashMap<String, f64>) -> f64;
}

/// Extract a single-node spec (mapping with 'type') or unpack a full-graph spec by root
pub(crate) fn extract_node_spec(val: &Value) -> Result<Value, String> {
    let map = val.as_mapping().ok_or_else(|| "Spec must be a mapping".to_string())?;
    // single-node spec
    if map.contains_key(&Value::String("type".into())) {
        return Ok(val.clone());
    }
    // graph spec
    let root = map
        .get(&Value::String("root".into()))
        .and_then(Value::as_str)
        .ok_or_else(|| "Missing 'root' in graph spec".to_string())?;
    // graph spec: nodes as mapping or sequence
    if let Some(nmap) = map.get(&Value::String("nodes".into())).and_then(Value::as_mapping) {
        return nmap
            .get(&Value::String(root.into()))
            .cloned()
            .ok_or_else(|| format!("Graph spec: root '{}' not found", root));
    }
    if let Some(nseq) = map.get(&Value::String("nodes".into())).and_then(Value::as_sequence) {
        for node in nseq {
            if let Some(m) = node.as_mapping() {
                if let Some(idv) = m.get(&Value::String("id".into())).and_then(Value::as_i64) {
                    if idv.to_string() == root {
                        return Ok(Value::Mapping(m.clone()));
                    }
                }
            }
        }
        return Err(format!("Graph spec: root '{}' not found in nodes list", root));
    }
    Err("Missing 'nodes' in graph spec".to_string())
}

/// Extension trait tying a YAML `type` tag to its builder.
/// Trait for spec types generated by `#[py_node]` to build engine nodes from YAML.
pub trait NodeDef: Sized {
    /// The `type` tag used in YAML to identify this node.
    const TYPE: &'static str;
    /// Build the concrete engine node from its YAML mapping.
    fn from_yaml(v: &Value) -> Result<Box<dyn Node + Send + Sync>, String>;
}

/// ------------------------------------------------------------------
/// PhaseÂ 3: Arena-based graph and engine
/// ------------------------------------------------------------------
/// Numeric index for nodes in the arena
pub type NodeId = usize;

/// A flat arena of nodes parsed from YAML.
#[derive(serde::Deserialize)]
pub struct ArenaNode {
    pub id: NodeId,
    #[serde(rename="type")]
    pub tag: String,
    #[serde(flatten)]
    pub fields: HashMap<String, FieldValue>,
}

/// A complete arena graph (list of nodes + root index).
#[derive(serde::Deserialize)]
pub struct ArenaGraph {
    pub nodes: Vec<ArenaNode>,
    pub root: NodeId,
}

/// Possible field values in the arena spec.
#[derive(serde::Deserialize)]
#[serde(untagged)]
pub enum FieldValue {
    One(NodeId),
    Many(Vec<NodeId>),
    Str(String),
    Float(f64),
}

impl ArenaGraph {
    /// Parse an arena graph from its YAML text.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }
}

/// Trait for engines that run an arena graph over input rows.
pub trait Engine {
    /// Given the arena and input rows, produce output rows.
    fn run(&self, graph: &ArenaGraph, rows: Vec<HashMap<String, f64>>)
        -> Vec<HashMap<String, f64>>;
}

/// Simple engine: trigger=graph.root, outputs are given indices.
pub struct ArenaEngine {
    pub outputs: Vec<NodeId>,
}
impl ArenaEngine {
    /// Create with the list of output node IDs to report.
    pub fn new(outputs: Vec<NodeId>) -> Self {
        Self { outputs }
    }
}
impl Engine for ArenaEngine {
    fn run(&self, graph: &ArenaGraph, rows: Vec<HashMap<String, f64>>)
        -> Vec<HashMap<String, f64>>
    {
        let mut results = Vec::new();
        for row in rows {
            // Topologically evaluate by arena order
            let mut vals = vec![0.0; graph.nodes.len()];
            for node in &graph.nodes {
                let v = match node.tag.as_str() {
                    "input" => {
                        if let FieldValue::Str(col) = &node.fields["name"] {
                            *row.get(col).unwrap_or(&0.0)
                        } else { 0.0 }
                    }
                    "const" => {
                        if let FieldValue::Float(f) = node.fields["value"] {
                            f
                        } else { 0.0 }
                    }
                    "add" => {
                        if let FieldValue::Many(ref children) = node.fields["children"] {
                            children.iter().map(|&i| vals[i]).sum()
                        } else { 0.0 }
                    }
                    "mul" => {
                        if let FieldValue::Many(ref children) = node.fields["children"] {
                            children.iter().map(|&i| vals[i]).product()
                        } else { 0.0 }
                    }
                    "div" => {
                        let l = if let FieldValue::One(i) = node.fields["left"] { vals[i] } else { 0.0 };
                        let r = if let FieldValue::One(i) = node.fields["right"] { vals[i] } else { 1.0 };
                        l / r
                    }
                    other => panic!("Unknown node tag {}", other),
                };
                vals[node.id] = v;
            }
            // Build output record: include trigger and outputs
            let mut rec = HashMap::new();
            rec.insert("trigger".to_string(), vals[graph.root]);
            for &out in &self.outputs {
                rec.insert(format!("output{}", out), vals[out]);
            }
            results.push(rec);
        }
        results
    }
}

/// Input node: reads a column by name.
pub struct InputNodeImpl {
    pub name: String,
}
impl InputNodeImpl {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "input";
}
impl Node for InputNodeImpl {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        *row.get(&self.name).unwrap_or(&0.0)
    }
}

/// Const node: always returns a constant.
pub struct ConstNode {
    pub value: f64,
}
impl ConstNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "const";
}
impl Node for ConstNode {
    fn eval(&self, _: &HashMap<String, f64>) -> f64 {
        self.value
    }
}

/// Add node: sums children.
pub struct AddNode {
    pub children: Vec<Box<dyn Node + Send + Sync>>,
}
impl AddNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "add";
}
impl Node for AddNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|c| c.eval(row)).sum()
    }
}

/// Mul node: multiplies children.
pub struct MulNode {
    pub children: Vec<Box<dyn Node + Send + Sync>>,
}
impl MulNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "mul";
}
impl Node for MulNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|c| c.eval(row)).product()
    }
}

/// Div node: left / right.
pub struct DivNode {
    pub left: Box<dyn Node + Send + Sync>,
    pub right: Box<dyn Node + Send + Sync>,
}
impl DivNode {
    /// `type` tag for this node in YAML.
    pub const TYPE: &'static str = "div";
}
impl Node for DivNode {
    fn eval(&self, row: &HashMap<String, f64>) -> f64 {
        let l = self.left.eval(row);
        let r = self.right.eval(row);
        l / r
    }
}
pub struct SamplerCore {
    trigger: Box<dyn Node + Send + Sync>,
    outputs: Vec<Box<dyn Node + Send + Sync>>,
}

impl SamplerCore {
    pub fn new(trigger_yaml: &str, output_yamls: &[&str]) -> Result<Self, String> {
        // unwrap either a single-node or full graph spec for trigger
        let tval: Value = serde_yaml::from_str(trigger_yaml).map_err(|e| e.to_string())?;
        let trigger_spec = extract_node_spec(&tval)
            .map_err(|e| format!("Invalid trigger spec: {}", e))?;
        let trigger = build_node(&trigger_spec)?;

        // unwrap each output spec similarly
        let mut outputs = Vec::with_capacity(output_yamls.len());
        for &yml in output_yamls {
            let oval: Value = serde_yaml::from_str(yml).map_err(|e| e.to_string())?;
            let spec = extract_node_spec(&oval)
                .map_err(|e| format!("Invalid output spec: {}", e))?;
            outputs.push(build_node(&spec)?);
        }
        Ok(SamplerCore { trigger, outputs })
    }

    pub fn run(&self, rows: Vec<HashMap<String, f64>>) -> Vec<HashMap<String, f64>> {
        let mut results = Vec::new();
        let mut prev: Option<f64> = None;
        for row in rows {
            let tval = self.trigger.eval(&row);
            if prev.map_or(true, |p| p != tval) {
                let mut rec = HashMap::new();
                rec.insert("trigger".to_string(), tval);
                for (i, node) in self.outputs.iter().enumerate() {
                    rec.insert(format!("output{}", i), node.eval(&row));
                }
                results.push(rec);
                prev = Some(tval);
            }
        }
        results
    }
}
