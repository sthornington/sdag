extern crate sdag_derive;

use pyo3::prelude::*;
use std::collections::HashMap;
use sdag_derive::SdagNode;

// Our simple macro system for traits
#[macro_use]
mod simple_node_macro;
use simple_node_macro::{EvalNode, ArenaEval};

// Engine module with arena types
mod engine;
use engine::{ArenaGraph, NodeId, ArenaNode};

// ===========================================================================
// NODE DEFINITIONS USING DERIVE MACRO
// ===========================================================================

#[derive(Debug, Clone, SdagNode)]
#[sdag(tag = "input")]
pub struct InputNode {
    pub name: String,
}

impl EvalNode for InputNode {
    fn eval(&self, _values: &[f64], inputs: &HashMap<String, f64>) -> f64 {
        *inputs.get(&self.name).unwrap_or(&0.0)
    }
}

#[derive(Debug, Clone, SdagNode)]
#[sdag(tag = "const")]
pub struct ConstNode {
    pub value: f64,
}

impl EvalNode for ConstNode {
    fn eval(&self, _values: &[f64], _inputs: &HashMap<String, f64>) -> f64 {
        self.value
    }
}

#[derive(Debug, Clone, SdagNode)]
#[sdag(tag = "add")]
pub struct AddNode {
    pub children: Vec<NodeId>,
}

impl EvalNode for AddNode {
    fn eval(&self, values: &[f64], _inputs: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|&id| values[id]).sum()
    }
}

#[derive(Debug, Clone, SdagNode)]
#[sdag(tag = "mul")]
pub struct MulNode {
    pub children: Vec<NodeId>,
}

impl EvalNode for MulNode {
    fn eval(&self, values: &[f64], _inputs: &HashMap<String, f64>) -> f64 {
        self.children.iter().map(|&id| values[id]).product()
    }
}

#[derive(Debug, Clone, SdagNode)]
#[sdag(tag = "div")]
pub struct DivNode {
    pub left: NodeId,
    pub right: NodeId,
}

impl EvalNode for DivNode {
    fn eval(&self, values: &[f64], _inputs: &HashMap<String, f64>) -> f64 {
        let l = values[self.left];
        let r = values[self.right];
        if r == 0.0 { f64::NAN } else { l / r }
    }
}

// ===========================================================================
// PYTHON CLASSES (generated by derive macro)
// ===========================================================================

// The derive macro generates these Python classes

// ===========================================================================
// MAIN STRUCTURES
// ===========================================================================

/// Python Graph builder
#[pyclass]
pub struct Graph {
    pub counter: usize,
    pub registry: HashMap<String, PyObject>,
}

#[pymethods]
impl Graph {
    #[new]
    fn new() -> Self {
        Graph {
            counter: 0,
            registry: HashMap::new(),
        }
    }
    
    fn freeze(&self, py: Python, root: PyObject) -> PyResult<String> {
        freeze_graph(self, py, root)
    }
    pub fn input(&mut self, py: Python, name: String) -> PyObject {
        let id = format!("n{}", self.counter);
        self.counter += 1;
        let node = Py::new(py, Input { id: id.clone(), name }).unwrap();
        let py_obj = node.into_py(py);
        self.registry.insert(id, py_obj.clone());
        py_obj
    }

    pub fn r#const(&mut self, py: Python, value: f64) -> PyObject {
        let id = format!("n{}", self.counter);
        self.counter += 1;
        let node = Py::new(py, Const { id: id.clone(), value }).unwrap();
        let py_obj = node.into_py(py);
        self.registry.insert(id, py_obj.clone());
        py_obj
    }

    pub fn add(&mut self, py: Python, children: Vec<PyObject>) -> PyObject {
        let id = format!("n{}", self.counter);
        self.counter += 1;
        let node = Py::new(py, Add { id: id.clone(), children }).unwrap();
        let py_obj = node.into_py(py);
        self.registry.insert(id, py_obj.clone());
        py_obj
    }

    pub fn mul(&mut self, py: Python, children: Vec<PyObject>) -> PyObject {
        let id = format!("n{}", self.counter);
        self.counter += 1;
        let node = Py::new(py, Mul { id: id.clone(), children }).unwrap();
        let py_obj = node.into_py(py);
        self.registry.insert(id, py_obj.clone());
        py_obj
    }

    pub fn div(&mut self, py: Python, left: PyObject, right: PyObject) -> PyObject {
        let id = format!("n{}", self.counter);
        self.counter += 1;
        let node = Py::new(py, Div { id: id.clone(), left, right }).unwrap();
        let py_obj = node.into_py(py);
        self.registry.insert(id, py_obj.clone());
        py_obj
    }
}

/// Python Sampler
#[pyclass]
struct Sampler {
    graph: String,
    outputs: Vec<usize>,
}

#[pymethods]
impl Sampler {
    #[new]
    #[pyo3(signature = (graph, outputs, _engine_name = "lazy"))]
    fn new(graph: &str, outputs: Vec<usize>, _engine_name: &str) -> PyResult<Self> {
        ArenaGraph::from_yaml(graph)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e))?;
        Ok(Sampler { 
            graph: graph.to_string(), 
            outputs,
        })
    }
    
    fn run(&self, rows: Vec<HashMap<String, f64>>) -> PyResult<Vec<HashMap<String, f64>>> {
        let arena = ArenaGraph::from_yaml(&self.graph)
            .map_err(|e| pyo3::exceptions::PyValueError::new_err(e))?;
        
        // Build nodes using registered builders
        let mut nodes: Vec<Box<dyn ArenaEval>> = Vec::new();
        for arena_node in &arena.nodes {
            let node = build_arena_node(arena_node)
                .map_err(|e| pyo3::exceptions::PyValueError::new_err(e))?;
            nodes.push(node);
        }
        
        // Run evaluation with trigger-based output
        let mut results = Vec::new();
        let mut prev_trigger: Option<f64> = None;
        
        for row in rows {
            let mut values = vec![0.0; arena.nodes.len()];
            
            // Evaluate all nodes
            for i in 0..arena.nodes.len() {
                values[i] = nodes[i].eval_arena(&values, &row);
            }
            
            // Check trigger
            let trigger_val = values[arena.root];
            if prev_trigger.map_or(true, |p| p != trigger_val) {
                let mut record = HashMap::new();
                record.insert("trigger".to_string(), trigger_val);
                
                for (i, &output_id) in self.outputs.iter().enumerate() {
                    record.insert(format!("output{}", i), values[output_id]);
                }
                
                results.push(record);
                prev_trigger = Some(trigger_val);
            }
        }
        
        Ok(results)
    }
}

/// Python module
#[pymodule]
fn sdag(_py: Python, m: &PyModule) -> PyResult<()> {
    // Register Python classes
    m.add_class::<Input>()?;
    m.add_class::<Const>()?;
    m.add_class::<Add>()?;
    m.add_class::<Mul>()?;
    m.add_class::<Div>()?;
    
    m.add_class::<Graph>()?;
    m.add_class::<Sampler>()?;
    Ok(())
}

// Helper function to build arena node
fn build_arena_node(node: &ArenaNode) -> Result<Box<dyn ArenaEval>, String> {
    match node.tag.as_str() {
        "input" => InputNode::from_arena(node).map(|n| Box::new(n) as Box<dyn ArenaEval>),
        "const" => ConstNode::from_arena(node).map(|n| Box::new(n) as Box<dyn ArenaEval>),
        "add" => AddNode::from_arena(node).map(|n| Box::new(n) as Box<dyn ArenaEval>),
        "mul" => MulNode::from_arena(node).map(|n| Box::new(n) as Box<dyn ArenaEval>),
        "div" => DivNode::from_arena(node).map(|n| Box::new(n) as Box<dyn ArenaEval>),
        _ => Err(format!("Unknown node type: {}", node.tag)),
    }
}

// Helper function for freeze
fn freeze_graph(graph: &Graph, py: Python, root: PyObject) -> PyResult<String> {
    use serde_yaml::{Mapping, Value};
    
    // Helper to get node type
    fn get_node_type(py: Python, obj: &PyObject) -> PyResult<String> {
        let cls_name = obj.as_ref(py).get_type().name()?;
        Ok(cls_name.to_string())
    }
    
    // Discover reachable nodes
    let mut seen = Vec::new();
    let root_str: String = root.as_ref(py).getattr("id")?.extract()?;
    let mut stack = vec![root.clone()];
    
    while let Some(obj) = stack.pop() {
        let id: String = obj.as_ref(py).getattr("id")?.extract()?;
        if seen.contains(&id) { continue; }
        seen.push(id.clone());
        
        // Check if node has children
        if let Ok(children) = obj.as_ref(py).getattr("children") {
            if let Ok(children_vec) = children.extract::<Vec<PyObject>>() {
                for child in children_vec {
                    stack.push(child);
                }
            }
        }
        
        // Check for left/right (binary nodes)
        if let Ok(left) = obj.as_ref(py).getattr("left") {
            if let Ok(left_obj) = left.extract::<PyObject>() {
                stack.push(left_obj);
            }
        }
        if let Ok(right) = obj.as_ref(py).getattr("right") {
            if let Ok(right_obj) = right.extract::<PyObject>() {
                stack.push(right_obj);
            }
        }
    }
    
    seen.reverse();
    
    // Build YAML
    let mut id2idx = HashMap::new();
    for (i, sid) in seen.iter().enumerate() {
        id2idx.insert(sid.clone(), i);
    }
    
    let mut nodes_seq = Vec::new();
    for sid in &seen {
        let obj = graph.registry.get(sid)
            .ok_or_else(|| pyo3::exceptions::PyValueError::new_err(format!("Unknown node '{}'", sid)))?;
        
        let mut mapping = Mapping::new();
        mapping.insert(Value::String("id".into()), serde_yaml::to_value(id2idx[sid]).unwrap());
        
        // Get node type (class name) and convert to tag
        let node_type = get_node_type(py, obj)?;
        let tag = match node_type.as_str() {
            "Input" => "input",
            "Const" => "const",
            "Add" => "add",
            "Mul" => "mul",
            "Div" => "div",
            _ => return Err(pyo3::exceptions::PyValueError::new_err(format!("Unknown node type: {}", node_type))),
        };
        mapping.insert(Value::String("type".into()), Value::String(tag.to_string()));
        
        // Extract fields based on node type
        match tag {
            "input" => {
                let name: String = obj.as_ref(py).getattr("name")?.extract()?;
                mapping.insert(Value::String("name".into()), Value::String(name));
            },
            "const" => {
                let value: f64 = obj.as_ref(py).getattr("value")?.extract()?;
                mapping.insert(Value::String("value".into()), serde_yaml::to_value(value).unwrap());
            },
            "add" | "mul" => {
                let children: Vec<PyObject> = obj.as_ref(py).getattr("children")?.extract()?;
                let mut idxs = Vec::new();
                for child in children {
                    let cid: String = child.as_ref(py).getattr("id")?.extract()?;
                    idxs.push(Value::Number(serde_yaml::Number::from(id2idx[&cid] as i64)));
                }
                mapping.insert(Value::String("children".into()), Value::Sequence(idxs));
            },
            "div" => {
                let left: PyObject = obj.as_ref(py).getattr("left")?.extract()?;
                let left_id: String = left.as_ref(py).getattr("id")?.extract()?;
                mapping.insert(Value::String("left".into()), Value::Number(serde_yaml::Number::from(id2idx[&left_id] as i64)));
                let right: PyObject = obj.as_ref(py).getattr("right")?.extract()?;
                let right_id: String = right.as_ref(py).getattr("id")?.extract()?;
                mapping.insert(Value::String("right".into()), Value::Number(serde_yaml::Number::from(id2idx[&right_id] as i64)));
            },
            _ => {},
        }
        
        nodes_seq.push(Value::Mapping(mapping));
    }
    
    let mut top = Mapping::new();
    top.insert(Value::String("nodes".into()), Value::Sequence(nodes_seq));
    top.insert(Value::String("root".into()), Value::Number(serde_yaml::Number::from(*id2idx.get(&root_str).unwrap() as i64)));
    
    serde_yaml::to_string(&Value::Mapping(top))
        .map_err(|e| pyo3::exceptions::PyValueError::new_err(e.to_string()))
        .map(|s| s.trim_end_matches('\n').to_string())
}